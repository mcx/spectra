// The case that the initial vector is in the null space of A
//
// In Spectra <= v1.2.0, the initial vector v is set to v = A * v0,
// where v0 is provided by the user or generated by random numbers
//
// However, I only tested whether ||v0|| != 0, but not ||v|| != 0,
// and directly did v /= vnorm, which would result in NaNs if vnorm == 0
//
// The correct way is to test whether vnorm == 0 first. If yes, then
// v0 is a (possibly unnormalized) eigenvector of A, so v can be set to v0 in this case
#include <iostream>
#include <Eigen/Core>
#include <Eigen/Eigenvalues>
#include <Spectra/SymEigsSolver.h>
#include <Spectra/MatOp/DenseSymMatProd.h>

#include "catch.hpp"

using namespace Spectra;

using Matrix = Eigen::MatrixXd;
using Vector = Eigen::VectorXd;

void run_test(Matrix& A, const Vector& v0)
{
    // True eigenvalues
    Eigen::SelfAdjointEigenSolver<Matrix> es(A);
    Vector true_evals = es.eigenvalues();

    // Largest eigenvalues
    DenseSymMatProd<double> op(A);
    SymEigsSolver<DenseSymMatProd<double>> eigs(op, 3, 6);

    eigs.init(v0.data());
    int nconv = eigs.compute(SortRule::LargestAlge, 1000, 1e-10, SortRule::SmallestAlge);
    int niter = eigs.num_iterations();
    int nops = eigs.num_operations();

    INFO("nconv = " << nconv);
    INFO("niter = " << niter);
    INFO("nops  = " << nops);
    REQUIRE(eigs.info() == CompInfo::Successful);

    Vector evals = eigs.eigenvalues();
    Matrix evecs = eigs.eigenvectors();
    Matrix resid = A.selfadjointView<Eigen::Lower>() * evecs - evecs * evals.asDiagonal();
    double err = resid.array().abs().maxCoeff();

    INFO("||AU - UD||_inf = " << err);
    REQUIRE(err == Approx(0.0).margin(1e-8));

    INFO("True eigenvalues =\n " << true_evals.tail(3));
    INFO("Estimated =\n " << evals);
    double diff = (true_evals.tail(3) - evals).array().abs().maxCoeff();
    INFO("diff = " << diff);
    REQUIRE(diff == Approx(0.0).margin(1e-8));
}

TEST_CASE("Case 1", "[example_init_null]")
{
    // A itself is a zero matrix
    std::srand(123);

    const int n = 100;
    Matrix A = Matrix::Zero(n, n);
    Vector v0 = Vector::Random(n);
    run_test(A, v0);
}

TEST_CASE("Case 2", "[example_init_null]")
{
    // A has zero eigenvalues, and the initial vector happens to be in the null space
    std::srand(123);

    const int n = 100;
    Matrix U = Matrix::Random(n, n);
    Matrix M = U + U.transpose();

    // True eigenvalues
    Eigen::SelfAdjointEigenSolver<Matrix> es(M);
    Vector evals = es.eigenvalues();
    Matrix evecs = es.eigenvectors();

    // Set the largest eigenvalue to be zero
    evals[n - 1] = 0.0;
    // Construct the A matrix
    Matrix A = evecs * evals.asDiagonal() * evecs.transpose();
    Vector v0 = evecs.col(n - 1);

    // Now we know that A * v0 = 0
    run_test(A, v0);
}
